
<html>
    <head>
        <title>Asteroids</title>
        <script type="text/javascript" src="./neural-network.js"></script>
    </head>

    <body>
        <canvas id="gameCanvas0" width="700" height="500"></canvas>
        <canvas id="gameCanvas1" width="700" height="500"></canvas>

        <script>
            const FPS = 60; //frames per second
            const FRICTION = 0.7; // friction coefficient of space (0 = no friction, 1 = lots of friction)
            const GAME_LIVES = 3; //starting number of lives
            const LASER_DIST = 0.6; //max distance laser can travel as fraction of screen width
            const LASER_EXPLODE_DUR = 0.3; //duration of the laser's explosion in seconds
            const LASER_MAX = 10; //max number of lasers on screen at once
            const LASER_SPD = 500; //speed of lasers in pixels per second
            const ROIDS_JAG = 0.4; //jaggedness of asteroids (0=none, 1=lots)
            const ROIDS_PTS_LRG = 20; //points scored for large asteroids
            const ROIDS_PTS_MED = 50; //points scored for medium asteroids
            const ROIDS_PTS_SML = 100; //points scored for small asteroids
            const ROIDS_NUM = 1; //starting number of asteroids
            const ROIDS_SIZE = 100; //starting size of asteroids in pixels
            const ROIDS_SPD = 100; //max start speed of asteroids in pixels per second
            const ROIDS_VERT = 10; //average number of vertices on each asteroid
            const SAVE_KEY_SCORE = "hi-score"; //save key for local storage of high score
            const SHIP_BLINK_DUR = 0.1; //duration of ship's blink during invisibility in seconds
            const SHIP_EXPLODE_DURATION = 0.3; //duration of the ship's explosion in seconds
            const SHIP_INV_DUR = 3; //duration of ship's invisibility in seconds
            const SHIP_SIZE = 30; //ship height in pixels
            const SHIP_THRUST = 5; //acceleration of the ship in pixels per second per second
            const SHIP_TURN_SPEED = 360; //turn speed in degrees per second
            const TEXT_FADE_TIME = 2.5; // text fade time in seconds
            const TEXT_SIZE = 40; //text font height in pixels 

            //developer flags
            const AUTOMATION_ON = true;
            const MUSIC_ON = false;
            const SHOW_BOUNDING = false; //show or hide collision bounding outline
            const SHOW_CENTER_DOT = false; //show or hide ship's center dot
            const SOUND_ON = true;

            // neural network parameters
            const NUM_INPUTS = 4; //asteroid-x, asteroid-y, angle to asteroid, ship's angle
            const NUM_HIDDEN = 20;
            const NUM_OUTPUT = 1;
            const NUM_SAMPLES = 500000; // number of training samples
            const OUTPUT_LEFT = 0; //expected neural output for turning left
            const OUTPUT_RIGHT = 1; //expected neural output for turning right
            const OUTPUT_THRESHOLD = 0.05; //how close the prediction must be to commit to a turn
            const RATE_OF_FIRE = 1;  // shots per second

            // multiple players
            const PLAYER_COMPUTER = 0; //computer player - neural network
            const PLAYER_HUMAN = 1; //human player - use keyboard

            /**
             * Neural network notes
             * 1.  Training with XOR.  When NUM_SAMPLES = 1000, training data for XOR test was bad.  E.g. [0,0] -> 0.6 (instead of 0.02) 
             *     When we bumped up the samples to 10,000, then the training data for the XOR test passed.
             * 
             * 2.  Training with XOR. If you don't add bias, sometimes the training data can produce bad results. E.g. [1,1] -> 0.5 (instead of 0.02) 
             *     Why do we add bias?  Because if the inputs are all [0,...,0], then the outputs will be [0,.., 0] and we
             *     will get skewed results.   
             *     The bias will be a non-zero input element into each layer of our network (inputs, and hidden layers)
             *        - A node of value [1] in the INPUT layer, times the bias weights, added to the other inputs, to calculate next layer
             *        - A node of value [1] in each HIDDEN layer, times the bias weights, added to the other layer nodes, to calculate next layer
             *
             * 3.  Training with ship/asteroid data.  If we don't "normaliseInput" into the train() method, then the (x,y) coords
             *     can have such a HUGE range.
             *        - asteroid-x can range from [-50...750]
             *        - asteroid-y can range from [-50...550]
             *        - ship-angle can range from [0, Math.PI * 2]
             *     So, we need to normal all the inputs between [0,1] by calling 'normaliseInput'
             * 
             */



            /** @type {HTMLCanvasElement} */
            var gCanv = [];
            var gCtx = [];
            gCanv[0] = document.getElementById("gameCanvas0");
            gCtx[0] = gCanv[0].getContext("2d");

            /** @type {HTMLCanvasElement} */
            gCanv[1] = document.getElementById("gameCanvas1");
            gCtx[1] = gCanv[1].getContext("2d");

            //set up sound effects.  
            // Sound is a custom class that we created so that we can play more than one audio file at once
            var fxExplode = new Sound("sounds/explode.m4a");
            var fxHit = new Sound("sounds/hit.m4a", 5);
            var fxLaser = new Sound("sounds/laser.m4a", 5, 0.3);
            var fxThrust = new Sound("sounds/thrust.m4a");

            //set up the music
            var music = new Music("sounds/music-low.m4a", "sounds/music-high.m4a");
            var gRoidsLeft, gRoidsTotal;

            //setup the game parameters
            var gLevel, gLives, gRoids, gScore, gScoreHigh, gShip, gText, gTextAlpha;

            //game params for computer player
            var gAiShootTime;

            //dan
            var players = [PLAYER_COMPUTER, PLAYER_HUMAN];
            var numPlayers = players.length;
            newGame();

            //set up the neural network
            var nn;
            if (AUTOMATION_ON) {
                nn = new NeuralNetwork(NUM_INPUTS, NUM_HIDDEN, NUM_OUTPUT);
                
                //train the network
                let ax, ay, sa, sx, sy;
                let ship = gShip[0]; //pick first player to train data
                let canv = gCanv[0];
                for (let i=0; i<NUM_SAMPLES; i++){

                    // random asteroid location (include offscreen data)
                    ax = Math.random() * (canv.width + ROIDS_SIZE) - ROIDS_SIZE / 2;
                    ay = Math.random() * (canv.height + ROIDS_SIZE) - ROIDS_SIZE / 2;

                    // ship's angle and position
                    sa = Math.random() * Math.PI * 2;
                    sx = ship.x;
                    sy = ship.y;

                    // calculate the angle to the asteroid
                    let angle = angleToPoint(sx, sy, sa, ax, ay);

                    // determine the direction to turn
                    let direction = angle > Math.PI ? OUTPUT_LEFT : OUTPUT_RIGHT;

                    //train the network
                    nn.train(normaliseInput(ax, ay, angle, sa), [direction]);
                }

                // TESTING
                // Train the network on XOR logic, and validate output
                //testXORLogic();
                // testMatrixFunctions();
            }

            //setup event handlers
            document.addEventListener("keydown", keyDown);
            document.addEventListener("keyup", keyUp);

            //set up the game loop
            setInterval(update, 1000 / FPS);

            function angleToPoint(x, y, bearing, targetX, targetY){
                let angleToTarget = Math.atan2(-targetY + y, targetX - x); // values in range [-180, 180]
                let diff = bearing - angleToTarget; //bearing in range [0, 360], so diff can be negative
                return (diff + Math.PI * 2) % (Math.PI * 2); //value between [0, Math.PI *2] in radians
            }

            function createAsteroidBelt(whichPlayer){
                let level = gLevel[whichPlayer];

                gRoids[whichPlayer] = [];  //clear asteroid array
                gRoidsTotal[whichPlayer] = (ROIDS_NUM + level) * 7; // need to shoot 7 things per asteroid (1 lrg, 2 med, 4 small)
                gRoidsLeft[whichPlayer] = gRoidsTotal[whichPlayer];

                let canv = gCanv[0];
                let roids = gRoids[whichPlayer];
                let roidsLeft = gRoidsLeft[whichPlayer];
                let roidsTotal = gRoidsTotal[whichPlayer];
                let ship = gShip[whichPlayer];


                let x, y;
                for (var i=0; i<ROIDS_NUM + level; i++){
                    do {
                        x = Math.floor(Math.random() * canv.width);
                        y = Math.floor(Math.random() * canv.height);
                    } while(distBetweenPoints(ship.x, ship.y, x, y) < ROIDS_SIZE * 2 + ship.r);
                    roids.push(newAsteroid(x, y, Math.ceil(ROIDS_SIZE/2), whichPlayer));
                }
            } 

            function destroyAsteroid(whichPlayer, index){

                let roids = gRoids[whichPlayer];
                let roidsLeft = gRoidsLeft[whichPlayer];
                let roidsTotal = gRoidsTotal[whichPlayer];

                var x = roids[index].x;
                var y = roids[index].y;
                var r = roids[index].r;

                //split asteroid in two if necessary
                if (r == Math.ceil(ROIDS_SIZE/2)){
                    roids.push(newAsteroid(x, y, Math.ceil(ROIDS_SIZE/4), whichPlayer))
                    roids.push(newAsteroid(x, y, Math.ceil(ROIDS_SIZE/4), whichPlayer))
                    gScore[whichPlayer] += ROIDS_PTS_LRG;
                }
                else if (r == Math.ceil(ROIDS_SIZE/4)){
                    roids.push(newAsteroid(x, y, Math.ceil(ROIDS_SIZE/8), whichPlayer))
                    roids.push(newAsteroid(x, y, Math.ceil(ROIDS_SIZE/8), whichPlayer))
                    gScore[whichPlayer] += ROIDS_PTS_MED;
                }
                else{
                    gScore[whichPlayer] += ROIDS_PTS_SML;
                }

                //check high score
                if (gScore[whichPlayer] > gScoreHigh[whichPlayer]){
                    gScoreHigh[whichPlayer] = gScore[whichPlayer];
                    localStorage.setItem(SAVE_KEY_SCORE + whichPlayer, gScoreHigh[whichPlayer]);
                }

                //destroy the original asteroid
                roids.splice(index, 1);
                fxHit.play();

                //calculate ratio of remaining asteroids to determine music tempo
                gRoidsLeft[whichPlayer]--;
                music.setAsteroidRatio(roidsLeft == 0 ? 1 : roidsLeft / roidsTotal);

                //new level when no more asteroids
                if (roids.length == 0){
                    gLevel[whichPlayer]++;
                    newLevel(whichPlayer);
                }
            }

            function distBetweenPoints(x1, y1, x2, y2){
                return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2-y1, 2));
            }

            function drawShip (x, y, a, whichPlayer, colour = "white"){
                let ctx = gCtx[whichPlayer];
                let ship = gShip[whichPlayer];

                ctx.strokeStyle = colour;
                ctx.lineWidth = SHIP_SIZE / 20;

                //draw a path
                ctx.beginPath();
                // the fractions 4/3, and 2/3 are to move center of ship to the centroid
                ctx.moveTo( //nose of ship
                    x + 4/3 * ship.r * Math.cos(a),
                    y - 4/3 * ship.r * Math.sin(a)  //negative indicates upwards on screen
                )
                ctx.lineTo( //rear left
                    x - ship.r * (2/3 * Math.cos(a) + Math.sin(a)),
                    y + ship.r * (2/3 * Math.sin(a) - Math.cos(a))
                )
                ctx.lineTo( //rear right
                    x - ship.r * (2/3 * Math.cos(a) - Math.sin(a)),
                    y + ship.r * (2/3 * Math.sin(a) + Math.cos(a))
                )
                ctx.closePath();                
                ctx.stroke(); 
            }

            function explodeShip(whichPlayer){
                let ship = gShip[whichPlayer];
                ship.explodeTime = Math.ceil(SHIP_EXPLODE_DURATION * FPS);
                fxExplode.play();
            }

            function gameOver(whichPlayer) {
                let ship = gShip[whichPlayer];
                ship.dead = true;
                gText[whichPlayer] = "Game Over";
                gTextAlpha[whichPlayer] = 1.0;
            }

            function getHumanPlayerIndex(){
                for (let i=0; i<players.length; i++){
                    if (players[i] == PLAYER_HUMAN){
                        return i;
                    }
                }
                return -1;
            }

            function keyDown(/** @type {KeyboardEvent} */ ev){
                let humanPlayer = getHumanPlayerIndex();
                if (humanPlayer < 0) {
                    console.log("No human player.  Ignoring keyboard");
                    return;
                }
                let ship = gShip[humanPlayer];

                // if (ship.dead || AUTOMATION_ON){
                if (ship.dead){
                    return;
                }
                switch(ev.keyCode){
                    case 32: //spacebar (shoot the laser)
                        shootLaser(humanPlayer);
                        break;
                    case 37: //left arrow (rotate ship left)
                        rotateShip(humanPlayer, false);
                        ship.rot = SHIP_TURN_SPEED / 180 * Math.PI / FPS;
                        break;
                    case 38: //up arrow (thrust ship forward)
                        ship.thrusting = true;
                        break;  
                    case 39: //right arrow (rotate ship right)
                        rotateShip(humanPlayer, true);
                        break
                        
                }
            }

            function keyUp(/** @type {KeyboardEvent} */ ev) {
                let humanPlayer = getHumanPlayerIndex();
                if (humanPlayer < 0) {
                    console.log("No human player.  Ignoring keyboard");
                    return;
                }
                let ship = gShip[humanPlayer];

                if (ship.dead){
                    return;
                }
                switch(ev.keyCode){
                    case 32: //spacebar (allow shooting again)
                        ship.canShoot = true;
                        break;
                    case 37: //left arrow (stop ship left)
                        ship.rot = 0;
                        break;
                    case 38: //up arrow (stop thrusting)
                        ship.thrusting = false;
                        break;
                    case 39: //right arrow (stop rotate ship right)
                        ship.rot = 0;
                        break
                        
                }

            }

            function newAsteroid(x, y, r, whichPlayer){

                let level = gLevel[whichPlayer];

                var lvlMult = 1 + 0.1 * level;

                var roid = {
                    x: x, 
                    y: y,
                    xv: Math.random() * ROIDS_SPD * lvlMult / FPS * ( Math.random() < 0.5 ? 1: -1), //x velocity
                    yv: Math.random() * ROIDS_SPD * lvlMult / FPS * ( Math.random() < 0.5 ? 1: -1), //y velocity
                    r: r, // asteroid radius
                    a: Math.random() * Math.PI * 2, // angle in radians
                    vert: Math.floor(Math.random() * (ROIDS_VERT + 1) + ROIDS_VERT / 2), //number of vertices
                    offsets: [],
                };

                //create the vertex offsets array
                for (var i=0; i<roid.vert; i++){
                    //ROID_JAG=0, offset = 1  (no jagged)
                    //ROID_JAG=1, offset in range {0..2}  (very jagged)
                    roid.offsets.push(Math.random() * ROIDS_JAG * 2 + (1 - ROIDS_JAG));
                }
                return roid;
            }

            // create a new game
            function newGame(){
                gAiShootTime = [];
                gLevel = [];
                gLives = [];
                gRoids = [];
                gRoidsLeft = [];
                gRoidsTotal = [];
                gScore = [];
                gScoreHigh = [];
                gShip = [];
                gText = [];
                gTextAlpha = [];
            

                let level = gLevel;
                let lives = gLives;
                let score = gScore;
                let ship = gShip;
                let scoreHigh = gScoreHigh;
                let aiShootTime = gAiShootTime;

                for (let whichPlayer=0; whichPlayer<numPlayers; whichPlayer++){
                    aiShootTime[whichPlayer] = 0;
                    level[whichPlayer] = 0;
                    lives[whichPlayer] = GAME_LIVES;
                    score[whichPlayer] = 0;
                    ship[whichPlayer] = newShip();


                    //get the high score from local storage
                    localStorage.setItem(SAVE_KEY_SCORE + whichPlayer, 0);
                    var scoreString = localStorage.getItem(SAVE_KEY_SCORE + whichPlayer);
                    if (scoreString == null){
                        scoreHigh[whichPlayer] = 0;
                    }
                    else {
                        scoreHigh[whichPlayer] = parseInt(scoreString);
                    }
                    newLevel(whichPlayer);
                }
            }

            //reset game for a specific player
            function resetGameFor(whichPlayer){
                gAiShootTime[whichPlayer] = 0;
                gLevel[whichPlayer] = 0;
                gLives[whichPlayer] = GAME_LIVES;
                gScore[whichPlayer] = 0;
                gShip[whichPlayer] = newShip();

                newLevel(whichPlayer);
            }

            function newLevel(whichPlayer){
                let level = gLevel[whichPlayer];

                gText[whichPlayer] = "Level " + (level + 1);
                gTextAlpha[whichPlayer] = 1.0;
                createAsteroidBelt(whichPlayer);
            }

            function newShip(){
                let canv = gCanv[0];

                var ship = {
                    x: canv.width / 2, //x-coord
                    y: canv.height / 2, //y-coord
                    r: SHIP_SIZE / 2, //radius of ship
                    a: 90 / 180 * Math.PI, // angle of ship, converted to radians
                    blinkNum: Math.ceil(SHIP_INV_DUR / SHIP_BLINK_DUR),
                    blinkTime: Math.ceil(SHIP_BLINK_DUR * FPS),
                    canShoot: true,
                    dead: false,
                    explodeTime: 0, 
                    lasers: [],
                    rot: 0, //rotation angle
                    thrusting: false,
                    thrust: {   //thrust magnitude
                        x: 0,
                        y: 0
                    }
                }
                return ship;
            }


            function normaliseInput(roidX, roidY, roidA, shipA){
                let canv = gCanv[0];

                //normalise the values to between 0 and 1
                let input = [];
                //each ship can be off screen by the radius of the ship
                input[0] = (roidX + ROIDS_SIZE / 2) / (canv.width + ROIDS_SIZE); 
                input[1] = (roidY + ROIDS_SIZE / 2) / (canv.height + ROIDS_SIZE); 
                input[2] = roidA / (Math.PI * 2);
                input[3] = shipA / (Math.PI * 2);
                return input;
            }

            function rotateShip(whichPlayer, right){
                let ship = gShip[whichPlayer];

                let sign = right ? -1 : 1;
                ship.rot = (SHIP_TURN_SPEED / 180) * (Math.PI / FPS) * sign;
            }


            function shootLaser(whichPlayer){
                let ship = gShip[whichPlayer];

                //create the laser object
                if (ship.canShoot && ship.lasers.length < LASER_MAX){
                    ship.lasers.push({ //from the nose of the ship
                        x: ship.x + 4/3 * ship.r * Math.cos(ship.a),
                        y: ship.y - 4/3 * ship.r * Math.sin(ship.a),
                        xv: LASER_SPD * Math.cos(ship.a) / FPS,
                        yv: -LASER_SPD * Math.sin(ship.a) / FPS,
                        dist: 0,
                        explodeTime: 0,
                    });
                    fxLaser.play();
                }

                //prevent further shooting
                ship.canShoot = false;
            }

            function Music(srcLow, srcHigh){
                this.soundLow = new Audio(srcLow);
                this.soundHigh = new Audio(srcHigh);
                this.low = true;
                this.tempo = 1.0; //seconds per beat
                this.beatTime = 0; //frames left until next beat

                this.play = function() {
                    if (MUSIC_ON) {
                        if (this.low){
                            this.soundLow.play();
                        } else {
                            this.soundHigh.play();
                        }

                        this.low = !this.low;
                    }
                }

                this.setAsteroidRatio = function(ratio) {
                    this.tempo = 1.0 - 0.75 * (1.0 - ratio);
                }

                this.tick = function(){
                    if (this.beatTime == 0){
                        this.play();
                        this.beatTime = Math.ceil(this.tempo * FPS);
                    } else {
                        this.beatTime--;
                    }
                }
            }

            //FYI: this is behaving like a 'class', not a 'function'
            function Sound(src, maxStreams = 1, vol = 1.0){
                this.streamNum = 0;
                this.streams = [];
                for (var i=0; i<maxStreams; i++){
                    this.streams.push(new Audio(src)); 
                    this.streams[i].volume = vol;
                }
                this.play = function(){
                    if (SOUND_ON){
                        this.streamNum = (this.streamNum + 1) % maxStreams;
                        this.streams[this.streamNum].play();
                    }
                }

                this.stop = function() {
                    this.streams[this.streamNum].pause();
                    this.streams[this.streamNum].currentTime = 0;
                }
            }

            function update() {
                for (let whichPlayer = 0; whichPlayer<numPlayers; whichPlayer++){

                    let aiShootTime = gAiShootTime[whichPlayer];
                    let canv = gCanv[0];
                    let ctx = gCtx[whichPlayer];
                    let level = gLevel[whichPlayer];
                    let lives = gLives[whichPlayer];
                    let roids = gRoids[whichPlayer];
                    let score = gScore[whichPlayer];
                    let scoreHigh = gScoreHigh[whichPlayer];
                    let ship = gShip[whichPlayer];
                    let isComputerPlayer = players[whichPlayer] == PLAYER_COMPUTER;

                    var blinkOn = ship.blinkNum % 2 == 0;
                    var exploding = ship.explodeTime > 0; //ship is exploding if > 0

                    //use the neural network to rotate the ship and shoot
                    if (AUTOMATION_ON && isComputerPlayer){

                        //compute the closest asteroid
                        let c = 0; //closest index
                        let dist0 = distBetweenPoints(ship.x, ship.y, roids[0].x, roids[0].y);
                        for (let i=1; i<roids.length; i++){
                            let dist1 = distBetweenPoints(ship.x, ship.y, roids[i].x, roids[i].y);
                            if (dist1 < dist0){
                                dist0 = dist1;
                                c = i;
                            }
                        }

                        //make a prediction based on current data
                        let ax = roids[c].x;
                        let ay = roids[c].y;
                        let sa = ship.a;
                        let sx = ship.x
                        let sy = ship.y
                        let angle = angleToPoint(sx, sy, sa, ax, ay);
                        let predict = nn.feedForward(normaliseInput(ax, ay, angle, sa)).data[0][0];

                        //make a turn
                        let dLeft = Math.abs(predict - OUTPUT_LEFT);
                        let dRight = Math.abs(predict - OUTPUT_RIGHT);
                        if (dLeft < OUTPUT_THRESHOLD){
                            rotateShip(whichPlayer, false);
                        } else if (dRight < OUTPUT_THRESHOLD){
                            rotateShip(whichPlayer, true);
                        } else {
                            //stop rotating
                            ship.rot = 0;
                        }

                        // shoot the laser
                        if (aiShootTime == 0){
                            gAiShootTime[whichPlayer] = Math.ceil(FPS / RATE_OF_FIRE);
                            ship.canShoot = true;
                            shootLaser(whichPlayer);
                        } else {
                            gAiShootTime[whichPlayer]--;
                        }
                    }

                    //tick the music
                    music.tick();

                    //draw space
                    ctx.fillStyle = "black";
                    ctx.fillRect(0, 0, canv.width, canv.height);

                    //thrust the ship only for human players
                    if (isComputerPlayer){

                    } else if (ship.thrusting && !ship.dead){
                        ship.thrust.x += SHIP_THRUST * Math.cos(ship.a) / FPS;
                        ship.thrust.y -= SHIP_THRUST * Math.sin(ship.a) / FPS;
                        fxThrust.play();

                        //draw the thruster
                        if (!exploding && blinkOn){
                            ctx.strokeStyle = "yellow";
                            ctx.fillStyle = "red";
                            ctx.lineWidth = SHIP_SIZE / 10;
                            ctx.beginPath();
                            ctx.moveTo( // rear left of ship
                                ship.x - ship.r * (2/3 * Math.cos(ship.a) + 0.5 * Math.sin(ship.a)),
                                ship.y + ship.r * (2/3 * Math.sin(ship.a) - 0.5 * Math.cos(ship.a))
                            )
                            ctx.lineTo( //rear center behind the ship
                                ship.x - ship.r * 6/3 * Math.cos(ship.a),
                                ship.y + ship.r * 6/3 * Math.sin(ship.a)
                            )
                            ctx.lineTo( //rear right
                                ship.x - ship.r * (2/3 * Math.cos(ship.a) - 0.5 * Math.sin(ship.a)),
                                ship.y + ship.r * (2/3 * Math.sin(ship.a) + 0.5 * Math.cos(ship.a))
                            )
                            ctx.closePath();       
                            ctx.fill();         
                            ctx.stroke(); 
                        }

                    } else {
                        ship.thrust.x -= FRICTION * ship.thrust.x / FPS;
                        ship.thrust.y -= FRICTION * ship.thrust.y / FPS;
                        fxThrust.stop();
                    }

                    //draw triangular ship
                    if (!exploding){
                        if (blinkOn && !ship.dead){
                            drawShip(ship.x, ship.y, ship.a, whichPlayer);
                        } 

                        //handle ship blinking
                        if (ship.blinkNum > 0) {

                            //reduce the blink time
                            ship.blinkTime--;

                            //reduce the blink num
                            if (ship.blinkTime == 0){
                                ship.blinkTime = Math.ceil(SHIP_BLINK_DUR * FPS);
                                ship.blinkNum--;
                            }
                        }
                        
                    } else{
                        //draw the explosion
                        ctx.fillStyle = "darkred";
                        ctx.beginPath();
                        ctx.arc(ship.x, ship.y, ship.r *1.7, 0, Math.PI * 2, false);
                        ctx.fill();
                        ctx.fillStyle = "red";
                        ctx.beginPath();
                        ctx.arc(ship.x, ship.y, ship.r *1.4, 0, Math.PI * 2, false);
                        ctx.fill();
                        ctx.fillStyle = "orange";
                        ctx.beginPath();
                        ctx.arc(ship.x, ship.y, ship.r *1.1, 0, Math.PI * 2, false);
                        ctx.fill();
                        ctx.fillStyle = "yellow";
                        ctx.beginPath();
                        ctx.arc(ship.x, ship.y, ship.r *0.8, 0, Math.PI * 2, false);
                        ctx.fill();
                        ctx.fillStyle = "white";
                        ctx.beginPath();
                        ctx.arc(ship.x, ship.y, ship.r *0.5, 0, Math.PI * 2, false);
                        ctx.fill();
                    }

                    if (SHOW_BOUNDING){
                        ctx.strokeStyle = "line";
                        ctx.beginPath();
                        ctx.arc(ship.x, ship.y, ship.r, 0, Math.PI * 2, false);
                        ctx.stroke();
                    }

                    //draw the asteroids
                    var x, y, r, a, vert, offsets;
                    for (var i=0; i<roids.length; i++){
                        ctx.strokeStyle = "slategrey";
                        ctx.lineWidth = SHIP_SIZE / 20;

                        //get the asteroid properties
                        x = roids[i].x;
                        y = roids[i].y;
                        r = roids[i].r;
                        a = roids[i].a;
                        vert = roids[i].vert;
                        offsets = roids[i].offsets;

                        //draw a path
                        ctx.beginPath();
                        ctx.moveTo(
                            x + r * offsets[0] * Math.cos(a),
                            y + r * offsets[0] * Math.sin(a)
                        );

                        //draw the polygon
                        for (var j=1; j<vert; j++){
                            ctx.lineTo(
                                x + r * offsets[j] * Math.cos(a + j * Math.PI * 2 / vert),
                                y + r * offsets[j] * Math.sin(a + j * Math.PI * 2 / vert)
                            );
                        }
                        ctx.closePath();
                        ctx.stroke();

                        if (SHOW_BOUNDING){
                            ctx.strokeStyle = "line";
                            ctx.beginPath();
                            ctx.arc(x, y, r, 0, Math.PI * 2, false);
                            ctx.stroke();
                        }
                    }

                    //center dot of ship
                    if (SHOW_CENTER_DOT){
                        ctx.fillStyle = "red";
                        ctx.fillRect(ship.x - 1, ship.y - 1, 2, 2);
                    }

                    //draw the lasers
                    for (var i=0; i<ship.lasers.length; i++){
                        if (ship.lasers[i].explodeTime == 0){
                            ctx.fillStyle = "salmon";
                            ctx.beginPath();
                            ctx.arc(ship.lasers[i].x, ship.lasers[i].y, SHIP_SIZE/15, 0, Math.PI*2, false);
                            ctx.fill();
                        }
                        else {
                            //draw the explosion
                            ctx.fillStyle = "orangered";
                            ctx.beginPath();
                            ctx.arc(ship.lasers[i].x, ship.lasers[i].y, ship.r * 0.75, 0, Math.PI*2, false);
                            ctx.fill();
                            ctx.fillStyle = "salmon";
                            ctx.beginPath();
                            ctx.arc(ship.lasers[i].x, ship.lasers[i].y, ship.r * 0.5, 0, Math.PI*2, false);
                            ctx.fill();
                            ctx.fillStyle = "pink";
                            ctx.beginPath();
                            ctx.arc(ship.lasers[i].x, ship.lasers[i].y, ship. r * 0.25, 0, Math.PI*2, false);
                            ctx.fill();

                        }
                    }

                    //draw the game text
                    if (gTextAlpha[whichPlayer] >= 0){
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.fillStyle = "rgba(255,255,255," + gTextAlpha[whichPlayer] + ")";
                        ctx.font = "small-caps " + TEXT_SIZE + "px dejavu sans mono";
                        ctx.fillText(gText[whichPlayer], canv.width/2, canv.height * 0.75);
                        gTextAlpha[whichPlayer] -= (1.0 / TEXT_FADE_TIME / FPS);
                    } else if (ship.dead){
                        // newGame();
                        resetGameFor(whichPlayer);
                    }

                    //draw the lives
                    var lifeColor;
                    for (var i=0; i< lives; i++){
                        lifeColor = exploding && i == lives - 1 ? "red" : "white";
                        drawShip(SHIP_SIZE + i * SHIP_SIZE* 1.2, SHIP_SIZE, 0.5 * Math.PI, whichPlayer, lifeColor);
                    }

                    //draw the score
                    ctx.textAlign = "right";
                    ctx.textBaseline = "middle";
                    ctx.fillStyle = "white";
                    ctx.font = TEXT_SIZE + "px dejavu sans mono";
                    ctx.fillText(score, canv.width - SHIP_SIZE/2, SHIP_SIZE);

                    //draw the high score
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillStyle = "white";
                    ctx.font = (TEXT_SIZE * 0.75) + "px dejavu sans mono";
                    ctx.fillText("BEST " + scoreHigh, canv.width/2, SHIP_SIZE);

                    //draw the level
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillStyle = "white";
                    ctx.font = (TEXT_SIZE * 0.5) + "px dejavu sans mono";
                    ctx.fillText("LEVEL " + (level+1), canv.width/2, SHIP_SIZE * 2);

                    //detect laser hits on asteroids
                    var ax, ay, ar, lx, ly;
                    for (var i=roids.length-1; i>=0; i--){

                        //grab the asteroid properties
                        ax = roids[i].x;
                        ay = roids[i].y;
                        ar = roids[i].r;

                        //loop over the lasers
                        for (var j=ship.lasers.length-1; j>=0; j--){
                            //grab laser properties
                            lx = ship.lasers[j].x;
                            ly = ship.lasers[j].y;

                            //detect hits
                            if (ship.lasers[j].explodeTime == 0 && distBetweenPoints(ax, ay, lx, ly) < ar){

                                //destroy the asteroid and activate laser explosion
                                ship.lasers[j].explodeTime = Math.ceil(LASER_EXPLODE_DUR * FPS);
                                destroyAsteroid(whichPlayer, i);
                                break;
                            }
                        }
                    }

                    //check for asteroid collisions with ship
                    if (!exploding){
                        if (ship.blinkNum == 0 && !ship.dead){
                            for (var i=0; i<roids.length; i++){
                                if (distBetweenPoints(ship.x, ship.y, roids[i].x, roids[i].y) < ship.r + roids[i].r){
                                    explodeShip(whichPlayer);
                                    destroyAsteroid(whichPlayer, i);
                                    break;
                                }
                            }
                        }
                    
                        //rotate ship
                        ship.a += ship.rot;

                        // keep the angle between 0 and 360 (two pi)
                        if (ship.a < 0) {
                            ship.a += (Math.PI * 2);
                        } else if (ship.a >= (Math.PI * 2)){
                            ship.a -= (Math.PI * 2);
                        }

                        //move ship
                        ship.x += ship.thrust.x;
                        ship.y += ship.thrust.y;
                    } else {
                        ship.explodeTime--;

                        //reset the ship after the explosion has finished
                        if (ship.explodeTime == 0){
                            gLives[whichPlayer]--;
                            if (gLives[whichPlayer] == 0){
                                gameOver(whichPlayer);
                            } else {
                                gShip[whichPlayer] = newShip();
                            }
                            
                        }
                    }

                    //handle edge of screen for ship
                    if (ship.x  < 0 - ship.r){
                        ship.x = canv.width + ship.r;
                    } else if (ship.x > canv.width + ship.r){
                        ship.x = 0 - ship.r;
                    }
                    if (ship.y  < 0 - ship.r){
                        ship.y = canv.height + ship.r;
                    } else if (ship.y > canv.height + ship.r){
                        ship.y = 0 - ship.r;
                    }

                    //move the lasers
                    for (var i=ship.lasers.length-1; i>=0; i--){
                        //check distance travelled
                        if (ship.lasers[i].dist > LASER_DIST * canv.width){
                            ship.lasers.splice(i, 1);
                            continue;
                        }

                        //handle the explosion
                        if (ship.lasers[i].explodeTime > 0){
                            ship.lasers[i].explodeTime--;

                            //destroy the laser after the duration is up
                            if (ship.lasers[i].explodeTime == 0){
                                ship.lasers.splice(i, 1);
                                continue;
                            }

                        }else {
                            //move the laser
                            ship.lasers[i].x += ship.lasers[i].xv;
                            ship.lasers[i].y += ship.lasers[i].yv;

                            //calculate distance travelled
                            ship.lasers[i].dist += Math.sqrt(Math.pow(ship.lasers[i].xv,2) + Math.pow(ship.lasers[i].yv,2));
                        }

                        //handle edge of screen
                        if (ship.lasers[i].x < 0){
                            ship.lasers[i].x = canv.width;
                        } else if (ship.lasers[i].x > canv.width){
                            ship.lasers[i].x = 0;
                        }
                        if (ship.lasers[i].y < 0){
                            ship.lasers[i].y = canv.height;
                        } else if (ship.lasers[i].y > canv.height){
                            ship.lasers[i].y = 0;
                        }
                    }

                    //move the asteroids
                    for (var i=0; i<roids.length; i++){
                        roids[i].x += roids[i].xv;
                        roids[i].y += roids[i].yv;

                        //handle edge of screen for asteroids
                        if (roids[i].x < 0 - roids[i].r){
                            roids[i].x = canv.width + roids[i].r;
                        } else if (roids[i].x > canv.width + roids[i].r){
                            roids[i].x = 0 - roids[i].r
                        }
                        if (roids[i].y < 0 - roids[i].r){
                            roids[i].y = canv.height + roids[i].r;
                        } else if (roids[i].y > canv.height + roids[i].r){
                            roids[i].y = 0 - roids[i].r
                        }
                    }
                } //end for(whichPlayer)
            }

            // TEST the matirx functions
            function testMatrixFunctions(){
                let m0 = new Matrix(2,3, [
                    [2,1, -1],
                    [4, 3, 0]
                ]);
                let m1 = new Matrix(2,3, [
                    [0, 1, -1],
                    [2, -3, 0]
                ]);
                let m2 = new Matrix(2,2, [
                    [1,-1],
                    [3, 0]
                ]);
                
                let arr = [4,5,6,7];
                // console.log(arr);
                console.table(m1.data); 
                console.table(Matrix.transpose(m1).data);
                // console.table(m2.data);
                // console.table(m1.data);
                // console.table(Matrix.dot(m2, m1).data);

            }


            // test XOR gate logic
            // 0 0 = 0
            // 0 1 = 1
            // 1 0 = 1
            // 1 1 = 0
            function testXORLogic(){
                let numInputs = 2;
                let numOutputs = 1;
                nn = new NeuralNetwork(numInputs, NUM_HIDDEN, numOutputs);
                
                //train the network
                for (let i=0; i<NUM_SAMPLES; i++){

                    let input0 = Math.round(Math.random()); // 0 or 1
                    let input1 = Math.round(Math.random()); // 0 or 1
                    let output = input0 == input1 ? 0 : 1;
                    nn.train([input0, input1], [output])
                }
                // test output
                console.log("0, 0 = " + nn.feedForward([0, 0]).data);
                console.log("0, 1 = " + nn.feedForward([0, 1]).data);
                console.log("1, 0 = " + nn.feedForward([1, 0]).data);
                console.log("1, 1 = " + nn.feedForward([1, 1]).data);
            }


        </script>
    </body>

</html>
